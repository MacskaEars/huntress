import argparse
import sys
import os
import time
import re

errs = {}
try:
    import requests
except ImportError:
    requests = None
    errs["ip"] = "For IP-based location etc., try `pip install requests`"

try:
    import pandas as pd
    from xhtml2pdf import pisa
except ImportError:
    errs["pdf"] = "For pdf support, try `pip install pandas xhtml2pdf`"


from jobs import run_job_search
from housing import run_housing_search

def today_tag():
    return time.strftime("%m%d%y")

def next_output_basename(mode, ext):
    """
    Find next available jobs_mmddyy_###.ext or housing_mmddyy_###.ext
    Abort if 999 already exist.
    """
    date = today_tag()
    prefix = f"{mode}_{date}_"

    existing = sorted(
        f for f in os.listdir(".")
        if f.startswith(prefix) and f.endswith(ext)
    )

    used_nums = []
    for f in existing:
        m = re.search(rf"{mode}_{date}_(\d{{3}})\.{ext}$", f)
        if m:
            used_nums.append(int(m.group(1)))

    used_nums = sorted(set(used_nums))

    for i in range(1, 1000):
        if i not in used_nums:
            return f"{prefix}{i:03d}"

    raise RuntimeError(f"More than 999 existing {mode} reports for today — aborting.")

def generate_html(df, mode, base):
    title = (
        "Huntress Job Search Results"
        if mode == "jobs"
        else "Huntress Housing Search Results"
    )

    accent = "#00ff00" if mode == "jobs" else "#ff00ff"

    html = f"""<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>{title}</title>
<style>
/* ----- SCREEN: NIGHT MODE ----- */
body {{
  background:#000;
  color:#fff;
  font-family: Helvetica, Arial, sans-serif;
  margin:0;
  padding:20px;
}}

.card {{
  border:1px solid #333;
  padding:15px;
  margin-bottom:15px;
  background:#111;
}}

@media print {{
  body {{ background:white; color:black; }}
  .card {{ background:white; border:1px solid #999; }}
}}

h1 {{
  color:{accent};
  border-bottom:2px solid #444;
}}
a {{ color:#ff00ff; }}
.footer {{
  margin-top:30px;
  font-size:10px;
  color:#555;
  text-align:center;
}}
</style>
</head>
<body>
<h1>{title}</h1>
<p>Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}</p>
"""

    for _, row in df.iterrows():
        subtitle = (
            row.get("company", "N/A")
            if mode == "jobs"
            else f"Price: {row.get('price','N/A')}"
        )

        score = (
            f"<b>Score: {row['score']}/100</b>"
            if "score" in row
            else ""
        )

        html += f"""
<div class="card">
  <div><b>{row.get('title','N/A')}</b> {score}</div>
  <div><i>{subtitle}</i></div>
  <div>Location: {row.get('location','Unknown')}</div>
  <div>Contact: {row.get('contact_info','N/A')}</div>
  <div><a href="{row.get('job_url','#')}">View Listing</a></div>
</div>
"""

    html += """<div class="footer">Generated by Huntress</div></body></html>"""

    path = f"{base}.html"
    with open(path, "w", encoding="utf-8") as f:
        f.write(html)

    return path, html


def generate_pdf(html, base):
    if errs.get("pdf"):
        print(errs["pdf"])
        return None
    path = f"{base}.pdf"
    with open(path, "wb") as f:
        pisa.CreatePDF(html, dest=f)
    return path


def generate_markdown(df, mode, base):
    path = f"{base}.md"
    with open(path, "w", encoding="utf-8") as f:
        f.write(f"# Huntress {mode.title()} Results\n\n")
        for _, r in df.iterrows():
            f.write(f"## {r.get('title','N/A')}\n")
            f.write(f"- Location: {r.get('location','Unknown')}\n")
            f.write(f"- Contact: {r.get('contact_info','N/A')}\n")
            f.write(f"- Link: {r.get('job_url','#')}\n\n")
    return path


def generate_txt(df, mode, base):
    path = f"{base}.txt"
    with open(path, "w", encoding="utf-8") as f:
        for _, r in df.iterrows():
            f.write(f"{r.get('title','N/A')} | {r.get('location','Unknown')}\n")
    return path

def get_location_by_ip():
    if errs.get("ip"):
        return None   # gracefully skip auto-detection

    try:
        r = requests.get("https://ipapi.co/json/", timeout=8)
        if r.status_code == 200:
            return r.json()
    except Exception:
        return None

def decide_mode(args):
    job_flags = bool(args.term)
    housing_flags = bool(args.max_rent or args.bedrooms)

    if args.jobs:
        return ["jobs"]
    if args.apartments:
        return ["apartments"]

    if job_flags and not housing_flags:
        return ["jobs"]
    if housing_flags and not job_flags:
        return ["apartments"]

    # Ambiguous → ask once
    print("\nArguments could apply to jobs, housing, or both.")
    try:
        choice = input("(j)obs, (a)partments, or (b)oth? [j]: ").lower()
    except (EOFError, OSError):
        print("\nNo interactive input available — defaulting to jobs.")
        choice = "j"

    if choice.startswith("a"):
        return ["apartments"]
    if choice.startswith("b"):
        return ["jobs", "apartments"]
    return ["jobs"]

def interactive_mode(args):
    print("\n--- Huntress Interactive Mode ---")

    modes = decide_mode(args)

    if "jobs" in modes and not args.term:
        raw = input("Job terms (comma-separated): ")
        args.term = [t.strip() for t in raw.split(",")] if raw else ["Software Engineer"]

    if not any([args.remote, args.local, args.global_mode, args.country, args.state, args.zip]):
        loc = get_location_by_ip()
        if loc:
            print(f"Detected: {loc.get('city')}, {loc.get('region')} {loc.get('postal')}")
            if input("Use this location? [y/n]: ").lower() != "n":
                args.zip = [loc.get("postal")]

    return modes

def run_and_output(modes, args):
    for mode in modes:
        df = (
            run_job_search(args)
            if mode == "jobs"
            else run_housing_search(args)
        )

        if df is None or df.empty:
            print(f"\n[!] No {mode} results.")
            continue

        # CSV always saved
        base = next_output_basename(mode, "csv")
        df.to_csv(f"{base}.csv", index=False)
        print(f"Saved: {base}.csv")

        # Decide formats
        want_html = args.html or not (args.html or args.pdf or args.md or args.txt)
        want_pdf = args.pdf
        want_md = args.md
        want_txt = args.txt

        if want_pdf or want_html:
            html_path, html = generate_html(df, mode, base)
            if html_path and html:
                print(f"Saved: {html_path}")
            else:
                continue
            if want_pdf:
                pdf_path = generate_pdf(html, base)
                if pdf_path:
                    print(f"Saved: {pdf_path}")
                else:
                    print("Could not save")

        if want_md:
            print(f"Saved: {generate_markdown(df, mode, base)}")

        if want_txt:
            print(f"Saved: {generate_txt(df, mode, base)}")

def parse_args():
    p = argparse.ArgumentParser(description="Huntress: Unified Search Tool")

    mode = p.add_mutually_exclusive_group()
    mode.add_argument("-j", "--jobs", action="store_true")
    mode.add_argument("-a", "--apartments", action="store_true")

    p.add_argument("-t", "--term", nargs="+")
    p.add_argument("--max-rent", type=int)
    p.add_argument("--bedrooms", type=int)

    p.add_argument("-r", "--remote", action="store_true")
    p.add_argument("-l", "--local", action="store_true")

    p.add_argument("-g", "--global-mode", action="store_true")
    p.add_argument("-c", "--country", nargs="+")
    p.add_argument("-s", "--state", nargs="+")
    p.add_argument("-z", "--zip", nargs="+")

    p.add_argument("--html", action="store_true")
    p.add_argument("--pdf", action="store_true")
    p.add_argument("--md", action="store_true")
    p.add_argument("--txt", action="store_true")

    p.add_argument("-i", "--interactive", action="store_true")

    args = p.parse_args()

    if len(sys.argv) == 1:
        args.interactive = True

    return args

if __name__ == "__main__":
    args = parse_args()

    if args.interactive:
        modes = interactive_mode(args)
    else:
        modes = decide_mode(args)

    run_and_output(modes, args)
